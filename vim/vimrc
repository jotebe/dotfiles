" vim: set noexpandtab tabstop=2 shiftwidth=0:

set nocompatible

" Plugin Load {
	filetype off " required by pathogen
	filetype plugin indent off

  let g:pathogen_disabled = ['vim-nodejs-complete']
	execute pathogen#infect()

	filetype plugin indent on  " Automatically detect file types. (must turn on after pathogen)

	" clear autocmds, to prevent compounding them when reloading this file
	autocmd!
" }

" Primary key setup {
	let mapleader=' ' " leader key is <space>
" }

" Looks {
	set showmode " display the current mode

	set cursorline " highlight current line
	set cursorcolumn
	" toggle cursor highlighting
	nnoremap <Leader>c :set cursorline!<CR>

	set colorcolumn=80,100 " Show lines on 80 and 100 chars

	set list
	set listchars=eol:◁,tab:»\ ,trail:·,nbsp:␣
" }

" Colors {
	colorscheme hybrid
" }

" Basic config {
	set ruler " show cursor position in the status bar
	syntax on " enable syntax highlighting

	set mouse=a

	" Absolute line numbers in insert mode, and relative in normal mode
	set number relativenumber
	autocmd InsertEnter * :set number norelativenumber
	autocmd InsertLeave * :set number relativenumber

	set encoding=utf-8
	set clipboard=unnamed

	" increase history length
	set history=1000
" }

" Whitespace {
	set tabstop=2
	set shiftwidth=2
	set softtabstop=2
	set expandtab
	set smartindent

	" remove trailing whitespace on save
	autocmd bufwritepre * :call FixTrailingWhitespace()
" }

" Searching {
	set hlsearch
	set incsearch
	set ignorecase
	set smartcase
	nnoremap N Nzz
	nnoremap n nzz

	" unset the "last search pattern" register by hitting return
	nnoremap <CR> :noh<CR><CR>
" }

" retain visual selection on < or > indent commands
vnoremap > >gv
vnoremap < <gv

" move the current line up and down
nnoremap <C-J> :m+<CR>==
nnoremap <C-K> :m-2<CR>==

" Tab completion
set wildmode=list:longest,list:full

" Ignored filetypes/directories
set wildignore+=*.o,*.obj,*.rbc,*.class,*.sassc,*.scssc,*.png,*.jpg,*.pdf,*.zip,*.gz
set wildignore+=tmp/*,log/*,public/assets/*,public/uploads/*
set wildignore+=vendor/bundler/*,vendor/bundle/*,vendor/gems/*
set wildignore+=**/coverage
set wildignore+=*.orig,.git,.svn
set wildignore+=db/sphinx/*

" always show status line for all windows
set laststatus=2

" Windows {
	set winwidth=84
	set noequalalways
" }

" autosave
" au FocusLost * silent! wa
" au BufLeave * silent! wa
" set autowrite

" Wrapping {
	set wrap linebreak " soft-wrap
	" set cpoptions+=v
	let &showbreak="___ " " wrapped-line indicator

	set textwidth=0 " wrap things at 80 chars

	set formatoptions+=l " don't break long lines in insert mode
	set formatoptions-=c " don't auto-wrap comments
	set formatoptions-=r " don't insert comment leader after <Enter> in insert mode
	set formatoptions+=o " insert comment leader on 'o' or 'O'
	set formatoptions+=j " remove comment leader in between joined lines
	set formatoptions+=n " recognize numbered lists and use for autoindent
	set formatoptions+=q " allow formatting comments with 'gq'
	set formatoptions-=t " don't use textwidth to auto-wrap text
" }

" allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Directories for swp files
set backupdir=~/.vim/backup
set directory=~/.vim/backup

" When a bracket is inserted, briefly jump to the matching one.  The
" jump is only done if the match can be seen on the screen.  The time to
" show the match can be set with 'matchtime'.
set showmatch

" Exit insert mode by mashing j and k
inoremap kj <esc>

" Save with leader-W
nmap <leader>w :w<cr>

nmap <leader>E :Explore<cr>

nmap <leader>o :!open "%"<cr><cr>

" Disable F1 for help
map <F1> <nop>

" Plugin configs {
	" CTRL-P {
		let g:ctrlp_map = '<leader>t'
		let g:ctrlp_working_path_mode = 0 "'ra'
		" let g:ctrlp_root_markers += 'package.json'
		let g:ctrlp_max_files = 10000
		let g:ctrlp_custom_ignore = {
			\ 'dir':  '\.git$|vendor\|\.hg$\|\.svn$\|\.yardoc\|public\/images\|public\/system\|log\|tmp\|node_modules\|dist$\|pkg',
			\ 'file': '\.exe$\|\.so$\|\.dat$'
			\ }
	" }

	" Syntastic {
		let g:syntastic_enable_signs=1
		" let g:syntastic_quiet_messages = {'level': 'warnings'}
		let g:syntastic_ruby_checkers=['mri']
		" let g:syntastic_ruby_checkers=['rubocop']
		let g:syntastic_go_checkers=['go']
		let g:syntastic_javascript_checkers=['jsxhint', 'jscs']

		set statusline=""
		set statusline+=%#warningmsg#%{SyntasticStatuslineFlag()}%*
		set statusline+=\ %<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %p%%

		let g:syntastic_always_populate_loc_list = 1
		let g:syntastic_auto_loc_list = 1
		let g:syntastic_check_on_open = 0
		let g:syntastic_check_on_wq = 0
	" }

	" Gundo {
		" Open undo tree buffer
		nnoremap <Leader>u :GundoToggle<CR>
	" }

	" YankRing {
		" Open Show yank ring buffer
		nnoremap <Leader>y :YRShow<CR>
		let g:yankring_history_dir = expand('$HOME').'/.vim'
	" }

	" Commentary {
		nmap <leader>/ <plug>CommentaryLine<CR>
		vmap <leader>/ <plug>Commentary<CR>
	" }

	" Fugitve {
		nmap <leader>gb :Gblame<CR>
		nmap <leader>gs :Gstatus<CR>
		nmap <leader>gd :Gdiff<CR>
		nmap <leader>gl :Glog<CR>
		nmap <leader>gc :Gcommit<CR>
	" }

	" Rails.vim {
		" Go to alternate file
		nnoremap <leader>a :A<CR>
	" }

	" Ruby {
		" Alternate between do; end and { } blocks in ruby
		let g:blockle_mapping = '<Leader>{'
		autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
		autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
		autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
		autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1
	" }

	" Dash.vim {
		nmap <silent> <leader>d <Plug>DashSearch
		vmap <silent> <leader>d "dy:Dash <C-R>d<CR>
	" }

	" Coffeescript {
	augroup CoffeeScript
		au!
		map <leader>C :CoffeeCompile vert<CR>
		vmap <leader>C <esc>:'<,'>:CoffeeCompile vert<CR>
		au BufNewFile,BufReadPost,BufWritePost *.coffee set foldmethod=indent
	augroup END

	" Go {
		let g:go_bin_path = expand("$GOPATH/bin")
	" }
	"
	" JavaScript {
		let g:javascript_conceal_function = "ƒ"
		let g:javascript_conceal_null = "ø"
		let g:javascript_conceal_this = "@"
		let g:javascript_conceal_return = "⇚"
		let g:javascript_conceal_undefined = "¿"
		let g:javascript_conceal_NaN = "ℕ"
		let g:javascript_conceal_prototype = "¶"
		let g:javascript_conceal_static = "•"
		let g:javascript_conceal_super = "Ω"

    au FileType javascript noremap <Leader>f :call FormatBuffer()<cr>
		let g:dash_map = {
        \ 'javascript' : 'nodejs'
			\ }

		" }
" }

" CTags {
	" Retag all files in project
	" map <Leader>rt :!ctags --extra=+f -R *<CR><CR>
	" map <C-\> :tnext<CR>

	" au BufWritePost *.rb silent! !ctags --extra=+f -R > /dev/null 2>&1 &
	" au BufWritePost *.coffee silent! !ctags --extra=+f -R > /dev/null 2>&1 &
	" au BufWritePost *.js silent! !ctags --extra=+f -R > /dev/null 2>&1 &
" }

" Filetypes {
	augroup filetypedetect
		" au!
		au BufRead,BufNewFile *_spec.rb set filetype=rspec.ruby
		au BufNewFile,BufReadPost *.md set filetype=markdown
		" Thorfile, Rakefile, Vagrantfile and Gemfile are Ruby
		au BufRead,BufNewFile {Capfile,Guardfile,Gemfile,Rakefile,Vagrantfile,Vagrantfile.*,Thorfile,config.ru} set ft=ruby

		" Nginx config
		au BufRead,BufNewFile *.conf set ft=nginx

		" AWS CloudFormation Templates
		au BufRead,BufNewFile *.template set ft=json

		" Force hamlc templates to syntax highlight (ghetto)
		au BufRead,BufNewFile *.hamlc set ft=haml

		au BufRead,BufNewFile,BufWritePost *.{scss,sass} set foldmethod=indent foldignore=""
	augroup END

	augroup vimrc
		au!
		au BufReadPre * setlocal foldmethod=indent
	augroup END

	" Autoreload when .vimrc files change
	augroup myvimrc
		au!
		au BufWritePost .vimrc,_vimrc,vimrc so $MYVIMRC
	augroup END
" }

" Fully unfold each file upon opening
au BufRead,BufNewFile * normal zR

" Ack for the current word
nmap <Leader>A :Ack -w <C-r><C-w>
vmap <Leader>A "dy:Ack <C-r>d

" replace the current word in the buffer
nmap <Leader>r :%s:\V\<<C-r><C-w>\>::gc<Left><Left><Left>
vmap <Leader>r "dy:%s:\V<C-r>d::gc<Left><Left><Left>

nmap <Leader>e :edit %%


" Add extra block object mods (eg ci/ ) {
	let pairs = [ ".", ":", ",", ";", "<bar>", "/", "<bslash>", "*", "( )", "{ }", "< >"]
	for keychars in pairs
		let keys = map(split(keychars), "substitute(v:val, '^\s*\(.\{-}\)\s*$', '\1', '')")
		let key = keys[0]
		let ekey = key

		if len(keys) > 1
			let ekey = keys[1]
		endif

		execute "nnoremap ci".key." f".ekey."cT".key
		execute "nnoremap di".key." f".ekey."dT".key
		execute "nnoremap yi".key." f".ekey."yT".key
		execute "nnoremap vi".key." f".ekey."vT".key
		execute "nnoremap ca".key." f".ekey."lcF".key
		execute "nnoremap da".key." f".ekey."ldF".key
		execute "nnoremap ya".key." f".ekey."lyF".key
		execute "nnoremap va".key." f".ekey."lvF".key
	endfor
" }

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Vimux
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Open vimux on the side
let g:VimuxOrientation = "h"

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Functions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

map <Leader>ra :call RunTestsSuite()<CR>
map <Leader>rf :call RunTestsFile()<CR>
map <Leader>rs :call RunTestsFileLine()<CR>
map <Leader>rl :call RunTestsAgain()<CR>

function! RunTestsSuite()
	call RunTests("run-tests suite")
endfunction

function! RunTestsFile()
		call RunTests("run-tests file " . @%)
endfunction

function! RunTestsFileLine()
		call RunTests("run-tests file " . @% . ":" . line("."))
endfunction

function! RunTestsAgain()
	if exists("t:run_test_last_command")
		call RunTests(t:run_test_last_command)
	endif
endfunction

function! RunTests(command)
	let t:run_test_last_command = a:command
	call VimuxRunCommand(a:command)
endfunction

function! s:RubyChangeHashSyntax(line1,line2)
		let l:save_cursor = getpos(".")
		silent! execute ':' . a:line1 . ',' . a:line2 . 's/\v:([a-z0-9_]+)\s*\=\>\s*/\1: /g'
		call setpos('.', l:save_cursor)
endfunction

command! -range=% RubyChangeHashSyntax call <SID>RubyChangeHashSyntax(<line1>,<line2>)
noremap <leader>rh :RubyChangeHashSyntax<cr>

command! -nargs=0 -bar Qargs execute 'args ' . s:QuickfixFilenames()

" Contributed by "ib."
" http://stackoverflow.com/questions/5686206/search-replace-using-quickfix-list-in-vim#comment8286582_5686810
command! -nargs=1 -complete=command -bang Qdo call s:Qdo(<q-bang>, <q-args>)

function! s:Qdo(bang, command)
	if exists('w:quickfix_title')
		let in_quickfix_window = 1
		cclose
	else
		let in_quickfix_window = 0
	endif

	arglocal
	exe 'args '.s:QuickfixFilenames()
	exe 'argdo'.a:bang.' '.a:command
	argglobal

	if in_quickfix_window
		copen
	endif
endfunction

function! s:QuickfixFilenames()
	" Building a hash ensures we get each buffer only once
	let buffer_numbers = {}
	for quickfix_item in getqflist()
		let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
	endfor
	return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

function! FixTrailingWhitespace()
	let l:winview = winsaveview()
	let l:folding = &foldenable
	let &foldenable = 0

	try
		" Remove trailing whitespace on all lines
		keepjumps % substitute/\v\s+$//e
		undojoin

		" Go to start of file and then delete <some whitespace> anchored by <end of file>
		keepjumps 0 goto
		keepjumps % substitute/\_s*\%$//e
	catch
	endtry

	let &foldenable = l:folding
	call winrestview(l:winview)
endfunction

function! FormatBuffer()
	let l:winview = winsaveview()
	let l:folding = &foldenable
	let &foldenable = 0

	try
    %! js-beautify -f -
	catch
	endtry

	let &foldenable = l:folding
	call winrestview(l:winview)
endfunction
